//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit
// swiftlint:disable colon
// swiftlint:disable nesting
// swiftlint:disable line_length
// swiftlint:disable comma
// swiftlint:disable opening_brace
/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try intern.validate()
  }
  static let appName = "バドハウス"
  static let appExplain = "このアプリはB版となります。\n もし,ご質問、不適切な投稿が確認できた場合は、下記のTwitterアカウントにご連絡ください。\n また、このアプリは現在地から近い順に練習を表示させるために位置情報を使用させていただいております。"
  static let address = "連絡先@katopan0405"
  static let cellId = "cellId"
    static let appRule = "利用規約\nこの利用規約（以下，「本規約」といいます。）は、このアプリの利用条件を定めるものです。\n登録ユーザーの皆さま（以下，「ユーザー」といいます。）には，本規約に従って，本サービスをご利用いただきます。\n第1条（適用）\n本規約は，ユーザーと当社との間の本サービスの利用に関わる一切の関係に適用されるものとします。当社は本サービスに関し，本規約のほか，ご利用にあたってのルール等，各種の定め（以下，「個別規定」といいます。）をすることがあります。これら個別規定はその名称のいかんに関わらず，本規約の一部を構成するものとします。本規約の規定が前条の個別規定の規定と矛盾する場合には，個別規定において特段の定めなき限り，個別規定の規定が優先されるものとします。\n第2条（利用登録）\n本サービスにおいては，登録希望者が本規約に同意の上，当社の定める方法によって利用登録を申請し，当社がこの承認を登録希望者に通知することによって，利用登録が完了するものとします。\n当社は，利用登録の申請者に以下の事由があると判断した場合，利用登録の申請を承認しないことがあり，その理由については一切の開示義務を負わないものとします。利用登録の申請に際して虚偽の事項を届け出た場合 本規約に違反したことがある者からの申請である場合 その他，当社が利用登録を相当でないと判断した場合 \n第3条（ユーザーIDおよびパスワードの管理）ユーザーは，自己の責任において，本サービスのユーザーIDおよびパスワードを適切に管理するものとします。\nユーザーは，いかなる場合にも，ユーザーIDおよびパスワードを第三者に譲渡または貸与し，もしくは第三者と共用することはできません。当社は，ユーザーIDとパスワードの組み合わせが登録情報と一致してログインされた場合には，そのユーザーIDを登録しているユーザー自身による利用とみなします。ユーザーID及びパスワードが第三者によって使用されたことによって生じた損害は，当社に故意又は重大な過失がある場合を除き，当社は一切の責任を負わないものとします。第4条（利用料金および支払方法）本サービスは無料で利用できるため本社からユーザーに料金を請求することは一切ありません。\n第5条（禁止事項）\nユーザーは，本サービスの利用にあたり，以下の行為をしてはなりません。\n法令または公序良俗に違反する行為犯罪行為に関連する行為 \n当社，本サービスの他のユーザー，または第三者のサーバーまたはネットワークの機能を破壊したり，妨害したりする行為 \n当社のサービスの運営を妨害するおそれのある行為 他のユーザーに関する個人情報等を収集または蓄積する行為 \n不正アクセスをし，またはこれを試みる行為 他のユーザーに成りすます行為 \n当社のサービスに関連して，反社会的勢力に対して直接または間接に利益を供与する行為 \n当社，本サービスの他のユーザーまたは第三者の知的財産権，肖像権，プライバシー，名誉その他の権利または利益を侵害する行為 以下の表現を含み，または含むと当社が判断する内容を本サービス上に投稿し，または送信する行為 過度に暴力的な表現 \n露骨な性的表現 人種，国籍，信条，性別，社会的身分，門地等による差別につながる表現 \n自殺，自傷行為，薬物乱用を誘引または助長する表現 その他反社会的な内容を含み他人に不快感を与える表現 \n以下を目的とし，または目的とすると当社が判断する行為 \n営業，宣伝，広告，勧誘，その他営利を目的とする行為（当社の認めたものを除きます。） \n性行為やわいせつな行為を目的とする行為 面識のない異性との出会いや交際を目的とする行為 \n他のユーザーに対する嫌がらせや誹謗中傷を目的とする行為 \n当社，本サービスの他のユーザー，または第三者に不利益，損害または不快感を与えることを目的とする行為 \nその他本サービスが予定している利用目的と異なる目的で本サービスを利用する行為 宗教活動または宗教団体への勧誘行為 その他，当社が不適切と判断する行為 \n第6条（本サービスの提供の停止等）\n 当社は，以下のいずれかの事由があると判断した場合，ユーザーに事前に通知することなく本サービスの全部または一部の提供を停止または中断することができるものとします。 \n本サービスにかかるコンピュータシステムの保守点検または更新を行う場合 \n地震，落雷，火災，停電または天災などの不可抗力により，本サービスの提供が困難となった場合 コンピュータまたは通信回線等が事故により停止した場合 その他，当社が本サービスの提供が困難と判断した場合 当社は，本サービスの提供の停止または中断により，ユーザーまたは第三者が被ったいかなる不利益または損害についても，一切の責任を負わないものとします。"
    struct swipeAction {
        static let block = "ブロック"
        static let withDraw = "退会"
    }
    struct SFSymbols {
        static let bell = "bell.fill"
        static let person = "person.fill"
        static let bubble = "bubble.left.fill"
        static let home = "homekit"
        static let calendar = "calendar"
        static let gear = "gearshape.fill"
        static let location = "location.north.circle.fill"
        static let magnifyingglass = "magnifyingglass.circle.fill"
        static let square = "square.and.pencil"
        static let paperPlane = "paperplane.fill"
        static let magnifying = "magnifyingglass.circle"
        static let plus = "plus.circle"
        static let person3 = "person.3"
        static let trash = "trash"
        static let list  = "list.bullet"
    }
    struct TabName {
        static let notification = "お知らせ"
        static let user = "ユーザー"
        static let talk = "トーク"
        static let home = "ホーム"
    }
    struct UserDefaultsKey {
        static let blocks = "blocks"
        static let friends = "friends"
        static let preJoin = "preJoin"
    }
    struct Collection {
        static let ChatRoom = "ChatRoom"
        static let Users = "Users"
        static let Practice = "Practice"
        static let PreJoined = "PreJoined"
        static let PreJoin = "PreJoin"
        static let Circle = "Circle"
    }
    
    struct buttonTitle {
        static let searchCircle = "サークルを探す"
        static let makeCircle = "サークルを作る"
        static let applyedUser = "申請済みのユーザー"
        static let alreadyApply = "申請済み"
        static let apply = "バド友申請"
        static let inviteCircle = "サークルへ招待"
        static let inviteFriend = "友だちを招待して作成"
        static let invite = "招待"
        static let post = "投稿する"
        static let next = "次へ"
        static let joinWait = "承認待ちの練習"
        static let join = "承認しました"
        static let takePartIn = "参加申請"
        static let logout = "ログアウト"
        static let report = "報告"
        static let stopPractice = "この練習の募集を停止する"
        static let searchFriends = "バド友を探す"
    }
    struct label {
        static let circle = "所属サークル"
        static let friends = "バド友"
    }
    struct placeholder {
        static let basic = "場所名,サークル名等,検索"
        static let input = "Aa"
    }
    struct charts {
        static let genderPer = "男女比"
    }
    struct alertMessage {
        static let ok = "OK"
        static let netError = "通信エラーです"
        static let placeError = "開催場所の正式名称を入力してください"
        static let searchError = "検索エラー"
        static let searchClear = "検索条件をクリアしました!"
        static let joinMessage = "参加申請しました"
        static let notNet = "ネットワークがつながっておりません"
        static let block = "通報しました"
        static let applyFriend = "友だち申請しました"
        static let noApplyFriend = "申請を取り下げました"
        static let thankYou = "報告ありがとうございました"
        static let notLogin = "ログインできませんでした"
        static let notRegister = "登録できません"
    }
    struct navTitle {
        static let one = "1/4"
        static let two = "2/4"
        static let three = "3/4"
        static let four = "4/4"
        static let settings = "設定画面"
        static let friends = "バド友申請一覧"
        static let problem = "不具合報告"
    }
    struct array {
        static let moneyArray = ["100", "200", "300", "400", "500", "600", "700", "800", "900",
                                 "1000", "1100", "1200", "1300", "1400", "1500", "1600", "1700",
                                 "1800", "1900", "2000", "2100", "2200", "2300", "2400", "2500",
                                 "2600", "2700", "2800", "2900", "3000"]
        static let levelSentence = ["まだバドミントンを初めて半年以内。\n基本的なショットや素振りなどの練習をしている",
                                    "バドミントンを初めて半年から1年,\nほとんどのショットを簡単にできる。\n[小学校]スクールに通っていた",
                                    "バドミントンを初めて1年以上。\n簡単な試合ができる。\n[中学校,高校]部活動に入部していた時期がある。\n[大学]サークルの練習で稀に練習している（月に一度等）\n[社会人]サークルで練習している",
                            "シングルス、ダブルス共に試合ができる。\n[中学校,高校]いずれかで3年間在籍していた。\n[大学]サークルの練習で定期的に練習している（2週に1度以上）\n[社会人]サークルで練習しており、2年以上は在籍している", "試合を連続して行うことができる。\n[中学校,高校]6年間在籍していた\n[大学]サークルの練習で定期的に練習しており、バドミントン歴4年以上\n[社会人]サークルで練習しており,オープン大会2回戦~3回戦",  "[中学校,高校]地区大会入賞、県大会出場等の結果を残している。\n[大学]サークルの練習で定期的に練習しており、バドミントン歴6年以上\n[社会人]サークルで練習しており,オープン大会中級レベルで勝利したことがある",
                                    "[中学校,高校]地区大会上位、県大会入賞等の結果を残している。\n[大学]関東リーグ4部〜5部,体育会に4年間所属していた。\n[社会人]サークルで練習しており,オープン大会上級レベルで勝利したことがある",
                                    "[中学校,高校]県大会上位,関東大会入賞　\n[大学]関東リーグ3~4部\n[社会人]サークルで練習しており,オープン大会上級レベルで入賞したことがある",
                                    "[中学校,高校]全国大会出場　\n[大学]関東リーグ2~3部。\n[社会人]全日本社会人等の大きい大会で入賞したことがある",
                                    "全国大会入賞、上位、関東リーグ1部~2部。\n実業団に所属している等のバドミントン界のトッププレイヤー"
        ]
        static let yearArray = ["1年未満", "1年~3年", "4年~6年", "7年~10年", "10年以上"]
        static let ageArray = ["10代以下", "10代", "20代", "30代", "40代", "50代", "60代", "70代以上"]
    }
    
  /// This `R.color` struct is generated, and contains static references to 4 colors.
  struct color {
    /// Color `AccentColor`.
    static let accentColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AccentColor")
    /// Color `StandardColor`.
    static let standardColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "StandardColor")
    /// Color `TFColor`.
    static let tfColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "TFColor")
    /// Color `backGroundColor`.
    static let backGroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "backGroundColor")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func accentColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.accentColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "StandardColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func standardColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.standardColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "TFColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func tfColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.tfColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "backGroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func backGroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.backGroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func accentColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.accentColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "StandardColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func standardColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.standardColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "TFColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func tfColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.tfColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "backGroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func backGroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.backGroundColor.name)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.entitlements` struct is generated, and contains static references to 1 properties.
  struct entitlements {
    struct comAppleDeveloperApplesignin {
      static let `default` = infoPlistString(path: ["com.apple.developer.applesignin"], key: "Default") ?? "Default"

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.file` struct is generated, and contains static references to 1 files.
  struct file {
    /// Resource file `GoogleService-Info.plist`.
    static let googleServiceInfoPlist = Rswift.FileResource(bundle: R.hostingBundle, name: "GoogleService-Info", pathExtension: "plist")

    /// `bundle.url(forResource: "GoogleService-Info", withExtension: "plist")`
    static func googleServiceInfoPlist(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.googleServiceInfoPlist
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 25 images.
  struct image {
    /// Image `arrow`.
    static let arrow = Rswift.ImageResource(bundle: R.hostingBundle, name: "arrow")
    /// Image `chat`.
    static let chat = Rswift.ImageResource(bundle: R.hostingBundle, name: "chat")
    /// Image `check`.
    static let check = Rswift.ImageResource(bundle: R.hostingBundle, name: "check")
    /// Image `circle-1`.
    static let circle1 = Rswift.ImageResource(bundle: R.hostingBundle, name: "circle-1")
    /// Image `circle`.
    static let circle = Rswift.ImageResource(bundle: R.hostingBundle, name: "circle")
    /// Image `double`.
    static let double = Rswift.ImageResource(bundle: R.hostingBundle, name: "double")
    /// Image `letter`.
    static let letter = Rswift.ImageResource(bundle: R.hostingBundle, name: "letter")
    /// Image `logo-1`.
    static let logo1 = Rswift.ImageResource(bundle: R.hostingBundle, name: "logo-1")
    /// Image `logo-2`.
    static let logo2 = Rswift.ImageResource(bundle: R.hostingBundle, name: "logo-2")
    /// Image `logo`.
    static let logo = Rswift.ImageResource(bundle: R.hostingBundle, name: "logo")
    /// Image `next`.
    static let next = Rswift.ImageResource(bundle: R.hostingBundle, name: "next")
    /// Image `noImages`.
    static let noImages = Rswift.ImageResource(bundle: R.hostingBundle, name: "noImages")
    /// Image `person`.
    static let person = Rswift.ImageResource(bundle: R.hostingBundle, name: "person")
    /// Image `purplechat.pnt`.
    static let purplechatPnt = Rswift.ImageResource(bundle: R.hostingBundle, name: "purplechat.pnt")
    /// Image `purplegear`.
    static let purplegear = Rswift.ImageResource(bundle: R.hostingBundle, name: "purplegear")
    /// Image `reload`.
    static let reload = Rswift.ImageResource(bundle: R.hostingBundle, name: "reload")
    /// Image `sad`.
    static let sad = Rswift.ImageResource(bundle: R.hostingBundle, name: "sad")
    /// Image `scroll`.
    static let scroll = Rswift.ImageResource(bundle: R.hostingBundle, name: "scroll")
    /// Image `search`.
    static let search = Rswift.ImageResource(bundle: R.hostingBundle, name: "search")
    /// Image `swift-og`.
    static let swiftOg = Rswift.ImageResource(bundle: R.hostingBundle, name: "swift-og")
    /// Image `ウォーク3`.
    static let ウォーク3 = Rswift.ImageResource(bundle: R.hostingBundle, name: "ウォーク3")
    /// Image `ウォーク4`.
    static let ウォーク4 = Rswift.ImageResource(bundle: R.hostingBundle, name: "ウォーク4")
    /// Image `ウォーク5`.
    static let ウォーク5 = Rswift.ImageResource(bundle: R.hostingBundle, name: "ウォーク5")
    /// Image `ウォーク6`.
    static let ウォーク6 = Rswift.ImageResource(bundle: R.hostingBundle, name: "ウォーク6")
    /// Image `ウォーク`.
    static let ウォーク = Rswift.ImageResource(bundle: R.hostingBundle, name: "ウォーク")
    static let shuttle = Rswift.ImageResource(bundle: R.hostingBundle, name: "shuttle")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "arrow", bundle: ..., traitCollection: ...)`
    static func arrow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.arrow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "chat", bundle: ..., traitCollection: ...)`
    static func chat(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.chat, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "check", bundle: ..., traitCollection: ...)`
    static func check(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.check, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "circle", bundle: ..., traitCollection: ...)`
    static func circle(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.circle, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "circle-1", bundle: ..., traitCollection: ...)`
    static func circle1(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.circle1, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "double", bundle: ..., traitCollection: ...)`
    static func double(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.double, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "letter", bundle: ..., traitCollection: ...)`
    static func letter(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.letter, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "logo", bundle: ..., traitCollection: ...)`
    static func logo(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.logo, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "logo-1", bundle: ..., traitCollection: ...)`
    static func logo1(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.logo1, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "logo-2", bundle: ..., traitCollection: ...)`
    static func logo2(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.logo2, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "next", bundle: ..., traitCollection: ...)`
    static func next(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.next, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "noImages", bundle: ..., traitCollection: ...)`
    static func noImages(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.noImages, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "person", bundle: ..., traitCollection: ...)`
    static func person(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.person, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "purplechat.pnt", bundle: ..., traitCollection: ...)`
    static func purplechatPnt(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.purplechatPnt, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "purplegear", bundle: ..., traitCollection: ...)`
    static func purplegear(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.purplegear, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "reload", bundle: ..., traitCollection: ...)`
    static func reload(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.reload, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "sad", bundle: ..., traitCollection: ...)`
    static func sad(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.sad, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "scroll", bundle: ..., traitCollection: ...)`
    static func scroll(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.scroll, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "search", bundle: ..., traitCollection: ...)`
    static func search(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.search, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "swift-og", bundle: ..., traitCollection: ...)`
    static func swiftOg(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.swiftOg, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ウォーク", bundle: ..., traitCollection: ...)`
    static func ウォーク(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ウォーク, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ウォーク3", bundle: ..., traitCollection: ...)`
    static func ウォーク3(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ウォーク3, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ウォーク4", bundle: ..., traitCollection: ...)`
    static func ウォーク4(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ウォーク4, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ウォーク5", bundle: ..., traitCollection: ...)`
    static func ウォーク5(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ウォーク5, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ウォーク6", bundle: ..., traitCollection: ...)`
    static func ウォーク6(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.ウォーク6, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.info` struct is generated, and contains static references to 1 properties.
  struct info {
    struct uiApplicationSceneManifest {
      static let _key = "UIApplicationSceneManifest"
      static let uiApplicationSupportsMultipleScenes = false

      struct uiSceneConfigurations {
        static let _key = "UISceneConfigurations"

        struct uiWindowSceneSessionRoleApplication {
          struct defaultConfiguration {
            static let _key = "Default Configuration"
            static let uiSceneConfigurationName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneConfigurationName") ?? "Default Configuration"
            static let uiSceneDelegateClassName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneDelegateClassName") ?? "$(PRODUCT_MODULE_NAME).SceneDelegate"

            fileprivate init() {}
          }

          fileprivate init() {}
        }

        fileprivate init() {}
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 33 nibs.
  struct nib {
    /// Nib `AccountSearchController`.
    static let accountSearchController = _R.nib._AccountSearchController()
    /// Nib `AdditionalEventElementController`.
    static let additionalEventElementController = _R.nib._AdditionalEventElementController()
    /// Nib `AdditionalEventTitleController`.
    static let additionalEventTitleController = _R.nib._AdditionalEventTitleController()
    /// Nib `AddtionalEventLevelController`.
    static let addtionalEventLevelController = _R.nib._AddtionalEventLevelController()
    /// Nib `AddtionalPlaceController`.
    static let addtionalPlaceController = _R.nib._AddtionalPlaceController()
    /// Nib `ChatCell`.
    static let chatCell = _R.nib._ChatCell()
    /// Nib `CheckNotificationController`.
    static let checkNotificationController = _R.nib._CheckNotificationController()
    /// Nib `CircleChatController`.
    static let circleChatController = _R.nib._CircleChatController()
    /// Nib `CircleDetailController`.
    static let circleDetailController = _R.nib._CircleDetailController()
    /// Nib `CircleSearchController`.
    static let circleSearchController = _R.nib._CircleSearchController()
    /// Nib `EventAdditionlItemsController`.
    static let eventAdditionlItemsController = _R.nib._EventAdditionlItemsController()
    /// Nib `EventInfoCell`.
    static let eventInfoCell = _R.nib._EventInfoCell()
    /// Nib `EventSearchController`.
    static let eventSearchController = _R.nib._EventSearchController()
    /// Nib `FriendsListController`.
    static let friendsListController = _R.nib._FriendsListController()
    /// Nib `InviteToCircleController`.
    static let inviteToCircleController = _R.nib._InviteToCircleController()
    /// Nib `LevelDetailController`.
    static let levelDetailController = _R.nib._LevelDetailController()
    /// Nib `LoginController`.
    static let loginController = _R.nib._LoginController()
    /// Nib `MainUserDetailController`.
    static let mainUserDetailController = _R.nib._MainUserDetailController()
    /// Nib `MainViewController`.
    static let homeViewController = _R.nib._MainViewController()
    /// Nib `MakeCircleController`.
    static let makeCircleController = _R.nib._MakeCircleController()
    /// Nib `MapListController`.
    static let mapListController = _R.nib._MapListController()
    /// Nib `MemberCell`.
    static let memberCell = _R.nib._MemberCell()
    /// Nib `NotificationCell`.
    static let notificationCell = _R.nib._NotificationCell()
    /// Nib `PracticeDetailController`.
    static let practiceDetailController = _R.nib._PracticeDetailController()
    /// Nib `RegisterController`.
    static let registerController = _R.nib._RegisterController()
    /// Nib `TalkCell`.
    static let talkCell = _R.nib._TalkCell()
    /// Nib `TalkViewController`.
    static let talkViewController = _R.nib._TalkViewController()
    /// Nib `UserCircleCell`.
    static let userCircleCell = _R.nib._UserCircleCell()
    /// Nib `UserController`.
    static let userController = _R.nib._UserController()
    /// Nib `UserLevelController`.
    static let userLevelController = _R.nib._UserLevelController()
    /// Nib `UserPageController`.
    static let userPageController = _R.nib._UserPageController()
    /// Nib `UserSettingsController`.
    static let userSettingsController = _R.nib._UserSettingsController()
      
    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AccountSearchController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.accountSearchController) instead")
    static func accountSearchController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.accountSearchController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AdditionalEventElementController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.additionalEventElementController) instead")
    static func additionalEventElementController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.additionalEventElementController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AdditionalEventTitleController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.additionalEventTitleController) instead")
    static func additionalEventTitleController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.additionalEventTitleController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AddtionalEventLevelController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.addtionalEventLevelController) instead")
    static func addtionalEventLevelController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.addtionalEventLevelController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AddtionalPlaceController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.addtionalPlaceController) instead")
    static func addtionalPlaceController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.addtionalPlaceController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ChatCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.chatCell) instead")
    static func chatCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.chatCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CheckNotificationController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.checkNotificationController) instead")
    static func checkNotificationController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.checkNotificationController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CircleChatController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.circleChatController) instead")
    static func circleChatController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.circleChatController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CircleDetailController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.circleDetailController) instead")
    static func circleDetailController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.circleDetailController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CircleSearchController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.circleSearchController) instead")
    static func circleSearchController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.circleSearchController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "EventAdditionlItemsController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.eventAdditionlItemsController) instead")
    static func eventAdditionlItemsController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.eventAdditionlItemsController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "EventInfoCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.eventInfoCell) instead")
    static func eventInfoCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.eventInfoCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "EventSearchController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.eventSearchController) instead")
    static func eventSearchController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.eventSearchController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "FriendsListController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.friendsListController) instead")
    static func friendsListController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.friendsListController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "InviteToCircleController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.inviteToCircleController) instead")
    static func inviteToCircleController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.inviteToCircleController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "LevelDetailController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.levelDetailController) instead")
    static func levelDetailController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.levelDetailController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "LoginController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.loginController) instead")
    static func loginController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.loginController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "MainUserDetailController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.mainUserDetailController) instead")
    static func mainUserDetailController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.mainUserDetailController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "MainViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.mainViewController) instead")
    static func mainViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.homeViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "MakeCircleController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.makeCircleController) instead")
    static func makeCircleController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.makeCircleController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "MapListController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.mapListController) instead")
    static func mapListController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.mapListController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "MemberCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.memberCell) instead")
    static func memberCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.memberCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "NotificationCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.notificationCell) instead")
    static func notificationCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.notificationCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "PracticeDetailController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.practiceDetailController) instead")
    static func practiceDetailController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.practiceDetailController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "RegisterController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.registerController) instead")
    static func registerController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.registerController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "TalkCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.talkCell) instead")
    static func talkCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.talkCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "TalkViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.talkViewController) instead")
    static func talkViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.talkViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "UserCircleCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.userCircleCell) instead")
    static func userCircleCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.userCircleCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "UserController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.userController) instead")
    static func userController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.userController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "UserLevelController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.userLevelController) instead")
    static func userLevelController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.userLevelController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "UserPageController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.userPageController) instead")
    static func userPageController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.userPageController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "UserSettingsController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.userSettingsController) instead")
    static func userSettingsController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.userSettingsController)
    }
    #endif

    static func accountSearchController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.accountSearchController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func additionalEventElementController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.additionalEventElementController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func additionalEventTitleController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.additionalEventTitleController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func addtionalEventLevelController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.addtionalEventLevelController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func addtionalPlaceController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.addtionalPlaceController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func chatCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ChatCell? {
      return R.nib.chatCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ChatCell
    }

    static func checkNotificationController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.checkNotificationController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func circleChatController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.circleChatController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func circleDetailController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.circleDetailController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func circleSearchController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.circleSearchController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func eventAdditionlItemsController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.eventAdditionlItemsController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func eventInfoCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> EventInfoCell? {
      return R.nib.eventInfoCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? EventInfoCell
    }

    static func eventSearchController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.eventSearchController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func friendsListController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.friendsListController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func inviteToCircleController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.inviteToCircleController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func levelDetailController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.levelDetailController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func loginController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.loginController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func mainUserDetailController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.mainUserDetailController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func mainViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.homeViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func makeCircleController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.makeCircleController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func mapListController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.mapListController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func memberCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> MemberCell? {
      return R.nib.memberCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? MemberCell
    }

    static func notificationCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> NotificationCell? {
      return R.nib.notificationCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? NotificationCell
    }

    static func practiceDetailController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.practiceDetailController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func registerController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.registerController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func talkCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CustomCell? {
      return R.nib.talkCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CustomCell
    }

    static func talkViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.talkViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

//    static func teammemberCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TeammemberCell? {
//      return R.nib.teammemberCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TeammemberCell
//    }

    static func userCircleCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UserCircleCell? {
      return R.nib.userCircleCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UserCircleCell
    }

    static func userController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.userController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func userLevelController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.userLevelController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func userPageController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.userPageController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func userSettingsController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.userSettingsController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 2 reuse identifiers.
  struct reuseIdentifier {
    /// Reuse identifier `CellId`.
    static let cellId: Rswift.ReuseIdentifier<UIKit.UICollectionViewCell> = Rswift.ReuseIdentifier(identifier: "CellId")
    /// Reuse identifier `eventId`.
    static let eventId: Rswift.ReuseIdentifier<UIKit.UICollectionViewCell> = Rswift.ReuseIdentifier(identifier: "eventId")

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try nib.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib: Rswift.Validatable {
    static func validate() throws {
      try _AdditionalEventElementController.validate()
      try _AdditionalEventTitleController.validate()
      try _AddtionalEventLevelController.validate()
      try _CircleDetailController.validate()
      try _LevelDetailController.validate()
      try _MakeCircleController.validate()
      try _PracticeDetailController.validate()
    }

    struct _AccountSearchController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "AccountSearchController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _AdditionalEventElementController: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "AdditionalEventElementController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "plus") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'plus' is used in nib 'AdditionalEventElementController', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "TFColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TFColor' is used in nib 'AdditionalEventElementController', but couldn't be loaded.") }
          if UIKit.UIColor(named: "backGroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'backGroundColor' is used in nib 'AdditionalEventElementController', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _AdditionalEventTitleController: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "AdditionalEventTitleController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "noImages", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'noImages' is used in nib 'AdditionalEventTitleController', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "TFColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TFColor' is used in nib 'AdditionalEventTitleController', but couldn't be loaded.") }
          if UIKit.UIColor(named: "backGroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'backGroundColor' is used in nib 'AdditionalEventTitleController', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _AddtionalEventLevelController: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "AddtionalEventLevelController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "info.circle.fill") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'info.circle.fill' is used in nib 'AddtionalEventLevelController', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }

    struct _AddtionalPlaceController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "AddtionalPlaceController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _ChatCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "ChatCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ChatCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ChatCell
      }

      fileprivate init() {}
    }

    struct _CheckNotificationController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "CheckNotificationController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _CircleChatController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "CircleChatController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _CircleDetailController: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "CircleDetailController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "logo", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'logo' is used in nib 'CircleDetailController', but couldn't be loaded.") }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "square.and.pencil") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'square.and.pencil' is used in nib 'CircleDetailController', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "backGroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'backGroundColor' is used in nib 'CircleDetailController', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _CircleSearchController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "CircleSearchController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _EventAdditionlItemsController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "EventAdditionlItemsController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _EventInfoCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "EventInfoCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> EventInfoCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? EventInfoCell
      }

      fileprivate init() {}
    }

    struct _EventSearchController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "EventSearchController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _FriendsListController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "FriendsListController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _InviteToCircleController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "InviteToCircleController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _LevelDetailController: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "LevelDetailController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "chevron.left") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'chevron.left' is used in nib 'LevelDetailController', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "backGroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'backGroundColor' is used in nib 'LevelDetailController', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _LoginController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "LoginController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _MainUserDetailController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "MainUserDetailController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _MainViewController: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = UIKit.UICollectionViewCell

      let bundle = R.hostingBundle
      let identifier = "eventId"
      let name = "HomeViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _MakeCircleController: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "MakeCircleController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "noImages", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'noImages' is used in nib 'MakeCircleController', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "backGroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'backGroundColor' is used in nib 'MakeCircleController', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _MapListController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "MapListController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _MemberCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "MemberCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> MemberCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? MemberCell
      }

      fileprivate init() {}
    }

    struct _NotificationCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "NotificationCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> NotificationCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? NotificationCell
      }

      fileprivate init() {}
    }

    struct _PracticeDetailController: Rswift.NibResourceType, Rswift.ReuseIdentifierType, Rswift.Validatable {
      typealias ReusableType = UIKit.UICollectionViewCell

      let bundle = R.hostingBundle
      let identifier = "CellId"
      let name = "PracticeDetailController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "info.circle.fill") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'info.circle.fill' is used in nib 'PracticeDetailController', but couldn't be loaded.") } }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "text.bubble.fill.rtl") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'text.bubble.fill.rtl' is used in nib 'PracticeDetailController', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "backGroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'backGroundColor' is used in nib 'PracticeDetailController', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _RegisterController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "RegisterController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _TalkCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "TalkCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CustomCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CustomCell
      }

      fileprivate init() {}
    }

    struct _TalkViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "TalkViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _UserCircleCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "UserCircleCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UserCircleCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UserCircleCell
      }

      fileprivate init() {}
    }

    struct _UserController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "UserController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _UserLevelController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "UserLevelController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _UserPageController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "UserPageController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }
 
    struct _UserSettingsController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "UserSettingsController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
